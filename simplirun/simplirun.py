# -*- coding: utf-8 -*-
"""
Spyder Editor

This is a temporary script file.
"""

__author__ = 'wlw'


import argparse
import errno
import os
import configparser
import re
import xml.dom.minidom
import time
import binascii

from datetime import datetime
from operator import itemgetter, attrgetter
from itertools import groupby, starmap

from openpyxl import load_workbook
from openpyxl.utils.cell import get_column_letter, column_index_from_string
from openpyxl.styles import PatternFill

from xml.dom.minidom import Node


class UserError(Exception):
    """Base class for all other simpliruna exceptions."""
    pass
    

class Log:
    """Contain log messages generated by the application

    First, The log messages will be stored in a message list. You can choose to output
    the messages to the console at the same time. The log messages will be recorded to
    a log file at anytime by calling the record method.

    Attributes:
    log_file : string --- the log file.
    message : list -- The list for storing the log message.
    """
    
    def __init__(self, logfile):
        self.logfile = logfile
        self.message = []


    def append(self, level, msg, console = True):
        """Append a piece of log message to the message list.

        There are three levels for the log message. '0' represents information message,
        '1' represents warning message and '2' represents fault message. You can choose
        whether to output the messages to console When appending the messages to the
        message list.

        Parameter:
        level : int --- the log message level number.
        msg : string --- the log message string.
        console : bool --- choose whether to output the messages to console or not.
        """
        symbol = [' ', '-', 'x']
        color = ['\033[94m\r', '\033[93m\r', '\033[91m\r']
        mark = 0 if level <= 0 else 2 if level >= 2 else level
        timestamp = f'[{datetime.now()}]'
        self.message.append(f'{symbol[mark]} {timestamp} {msg}')
        if console:
            print(f'{color[mark]}{symbol[mark]} {timestamp} {msg}')


    def record(self):
        """Record log messages to a log file.

        In this function, the log messages stored in the message list will be recorded to
        a log file.
        """
        with open(self.logfile, 'w') as file:
            for msg in self.message:
                file.write(msg + '\n')


class Busy:
    """Contain and display the busy symbols indicating the process is in progress.
    
    The four busy symbols '/', '-', '\', '|' will be displayed in the same screen position
    cyclically. The offset value specifies the number of space characters between the left
    of the screen and the busy symbol.
    
    Attributes:
    offset : int -- The offset form the left of the screen.
    """

    def __init__(self, offset = 0):
        self.symbol = ('/', '-', '\\', '|')
        self.offset = offset
        self.now = 0


    def busy_now(self, info = ''):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : string --- the information displayed after the busy symbol.
        """
        self.now = (self.now + 1) % 4
        print('\r' + ' ' * self.offset + f'{self.symbol[self.now]} {info}', end = '') 


class ProjectParser:
    """Contain the project argument

    Parse and verify the project arguments.

    Attributes:
    template_file : str -- The equipment template file.
    framework_file : str -- The application framework file.
    list_file_dir : str -- The equipment list file directory.
    """
    
    def __init__(self):
        self.template_file = None
        self.library_dir = None
        self.project_dir = None
    
    
    def read(self, project_file):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        if not isthistype(project_file, '.pro') or not os.path.isfile(project_file):
            raise UserError(f'Trying to open a non project file(.pro) or file doesn\'t exist: \'{project_file}\'')
        
        config = configparser.ConfigParser()
        config.read(project_file)
        template_file = config.get('Arguments', 'TemplateFile')
        library_dir = config.get('Arguments', 'LibraryDirectory')
        project_dir = config.get('Arguments', 'ProjectDirectory')
        
        path = os.path.dirname(project_file)
        self.template_file = os.path.normpath(os.path.join(path, template_file))
        self.library_dir = os.path.normpath(os.path.join(path, library_dir))
        self.project_dir = os.path.normpath(os.path.join(path, project_dir))


class TemplateParser:
    """Contain the project argument

    Parse and verify the project arguments.

    Attributes:
    equipment_template_file : str -- The equipment template file.
    app_framework_file : str -- The application framework file.
    list_file_dir : str -- The equipment list file directory.
    """
    
    def __init__(self):
        self.function_blocks = {}
        self.template_file = None


    def read(self, template_file):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        titles_key = ['设备类型']
        titles_fb_general = ['类型说明', '功能块名称']
        titles_fb_parameter = ['参数名称', '参数类型', '数据类型', '参数标识', '联动参数']
        titles_function_block = titles_fb_general + titles_fb_parameter
        titles_template = titles_key + titles_function_block
        
        if not isthistype(template_file, '.xlsx') or not os.path.isfile(template_file):
            raise UserError(f'Trying to open a non template file(.xlsx) or file doesn\'t exist: \'{template_file}\'')
        self.template_file = template_file
        
        wb = load_workbook(template_file)
        ws = wb['设备模板']
        
        titles_sheet = [cell.value for cell in ws[1]]
        
        titles_absence = [title for title in titles_template if title not in titles_sheet]
        if titles_absence:
            raise UserError(f'Column(s): {titles_absence} not found in {template_file}:{ws}')
        
        titles_column = {t: get_column_letter(titles_sheet.index(t) + 1) for t in titles_template}
        
        column = titles_column[titles_key[0]]
        cells = ws[f'{column}2':f'{column}{ws.max_row}']
        block_top = [cell.row for cell, in cells if type(cell).__name__ == 'Cell']
        block_bottom = [row - 1 for row in block_top[1:] + [ws.max_row + 1]]
        block_span = list(zip(block_top, block_bottom))
        
        for top, bottom in block_span:
            keys = ws['{0}{1}'.format(titles_column[titles_key[0]], top)].value
            keys_list = keys.split('/')
            
            function_block = []
            for title in titles_fb_general:
                function_block.append(ws['{0}{1}'.format(titles_column[title], top)].value)
            
            parameters_column = []
            for title in titles_fb_parameter:
                cells = ws[f'{titles_column[title]}{top}':f'{titles_column[title]}{bottom}']
                parameters_column.append([cell.value for cell, in cells])
            
            parameters = list(zip(*parameters_column))
            function_block.append(parameters)
            
            self.function_blocks.update(dict(zip(keys_list, [function_block] * len(keys_list))))

            
    def get_functionblock(self, key):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        try:
            return self.function_blocks[key]
        except KeyError:
            raise UserError('Invalid key \'{0}\''.format(key))
    

class EquipmentListParser:
    """Contain the project argument

    Parse and verify the project arguments.

    Attributes:
    equipment_template_file : str -- The equipment template file.
    app_framework_file : str -- The application framework file.
    list_file_dir : str -- The equipment list file directory.
    """
    
    def __init__(self):
        self.modules_support = {'PS: BMX CPS 3500':'ps', 'CPU: BMX P34 2020':'cpu', 'DI: BMX DDI 3202K':'di',
                                'DO: BMX DDO 3202K':'do', 'AI: BMX AMI 0810':'ai', '(EMPTY)':'emp'}
        self.modules_config = {}
        self.modules_config_idx = {}
        self.workbook = None
        self.list_file = None
    
    
    def load_eqipmentlist(self, list_file):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        if not isthistype(list_file, '.xlsx') or not os.path.isfile(list_file):
            raise UserError(f'Trying to open a non list file(.xlsx) or file does not exist: \'{list_file}\'')
        
        self.list_file = list_file
        self.workbook = load_workbook(list_file)
        ws = self.workbook['控制器配置']
        cells = ws['C3':'N4']
        self.modules_config = {f'{r}:{m:02}':module.value for r, rack in enumerate(cells) for m, module in enumerate(rack)}
        modules_unsup = {p:m for p, m in self.modules_config.items() if m not in self.modules_support.keys()}
        if modules_unsup:
            raise UserError(f'Unsupported module(s): {modules_unsup} found in {list_file}')
        
        modules_config_type = {p:self.modules_support[m] for p, m in self.modules_config.items()}
        s = sorted(modules_config_type.items(), key = itemgetter(0))
        modules_config_sorted = sorted(s, key = itemgetter(1))
        modules_config_grouped = groupby(modules_config_sorted, key = itemgetter(1))
        self.modules_config_idx = {f'{m[1]}{i+1}':m[0] for k, g in modules_config_grouped for i, m in enumerate(g)}
        
        
    def iter_equipments(self):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        titles_key = ['设备类型']
        titles_ep_general = ['设备名称', '安装位置', '18位编码', '设备ID', '设备编号']
        titles_ep_parameter = ['参数1', '参数2', '参数3', '参数4', '参数5', '参数6', '参数7']
        titles_equipment = titles_ep_general + titles_ep_parameter
        titles_eplist = titles_key + titles_equipment
        
        ws = self.workbook['设备列表']
        titles_sheet = [cell.value for cell in ws[1]]
        
        titles_absence = [title for title in titles_eplist if title not in titles_sheet]
        if titles_absence:
            raise UserError(f'Column(s): {titles_absence} not found in {self.list_file}:{ws}')
        
        titles_column = {t: get_column_letter(titles_sheet.index(t) + 1) for t in titles_eplist}
        for row in range(2, ws.max_row + 1):
            key = ws[f'{titles_column[titles_key[0]]}{row}'].value
            equipment = [ws[f'{titles_column[t]}{row}'].value for t in titles_ep_general]
            equipment.append([ws[f'{titles_column[t]}{row}'].value for t in titles_ep_parameter])
            equipment[-1] = list(map(self._get_parameter_addr, equipment[-1]))
            yield key, equipment
            
            
    def _get_parameter_addr(self, parameter):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        if parameter == '/':
            return parameter
        if re.match(r'^DIX\d{1,2}:\d{1,3}$', parameter):
            return self._get_di_addr(parameter)
        if re.match(r'^DQX\d{1,2}:\d{1,2}A$', parameter):
            return self._get_do_addr(parameter)
        if re.match(r'^PIM\d{1,2}S\d{1,2}\+$', parameter):
            return self._get_ai_addr(parameter)
        return parameter
        
    
    def _get_di_addr(self, str_di):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        raw_addr = str_di[3:].split(':')
        try:
            module_addr = self.modules_config_idx['di{0}'.format(raw_addr[0].lstrip('0'))]
        except KeyError:
            raise UserError('Invalid DI address {0}'.format(str_di))
        rack, module = [int(s) for s in module_addr.split(':')]
        chn_raw = raw_addr[1].zfill(3)
        chn = int(chn_raw[0]) * 16 + int(chn_raw[1:]) - 1
        return f'%I{rack}.{module}.{chn}'
    
    
    def _get_do_addr(self, str_do):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        raw_addr = str_do[3:-1].split(':')
        try:
            module_addr = self.modules_config_idx['do{0}'.format((int(raw_addr[0]) + 1) // 2)]
        except KeyError:
            raise UserError('Invalid DO address {0}'.format(str_do))
        rack, module = [int(s) for s in module_addr.split(':')]
        chn = ((int(raw_addr[0]) + 1) % 2) * 16 + int(raw_addr[1]) - 1
        return f'%Q{rack}.{module}.{chn}'
        
    
    def _get_ai_addr(self, str_ai):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        raw_addr = str_ai[3:-1].split('S')
        try:
            module_addr = self.modules_config_idx['ai{0}'.format(int(raw_addr[0]))]
        except KeyError:
            raise UserError('Invalid AI address {0}'.format(str_ai))
        rack, module = [int(s) for s in module_addr.split(':')]
        chn = int(raw_addr[1]) - 1
        return f'%IW{rack}.{module}.{chn}'


class StationBuilder:
    """Contain the project argument

    Parse and verify the project arguments.

    Attributes:
    equipment_template_file : str -- The equipment template file.
    app_framework_file : str -- The application framework file.
    list_file_dir : str -- The equipment list file directory.
    """
    
    def __init__(self):
        self.template = None
        self.xdb_files = {}
        self.xdb = {}
        self.map = {}
        self.equipments = None
        self.equipments_iter = None
        self.equipment_list = []
        self.main_src = []
        self.edt = []
        self.xdb_in_listfile = set()
        self.dom = None

    
    def load_template(self, template_file):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        self.template = TemplateParser()
        self.template.read(template_file)
        

    def load_xdb(self, lib_dir):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        if not os.path.isdir(lib_dir):
            raise UserError(f'Library directory \'{lib_dir}\' doesn\'t exist.')
        
        dirpath, dirnames, filenames = next(os.walk(lib_dir))
        self.xdb_files = {os.path.splitext(f)[0]:os.path.join(dirpath, f) for f in filenames if isthistype(f, '.xdb')}
        
        xdb_dom = {xdb:xml.dom.minidom.parse(file) for xdb, file in self.xdb_files.items()}
        
        self.xdb = {xdb:ele for xdb, dom in xdb_dom.items() for ele in dom.getElementsByTagName('FBSource') if ele.getAttribute('nameOfFBType').lower() == xdb}
        
        
    def load_equipments(self, list_file):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        self.map = {'AS':{'INT':[-1, 1], 'DINT':[98, 2], 'REAL':[198, 2]}, 'AF':{'INT':[299, 1], 'DINT':[498, 2], 'REAL':[698, 2]}}
        self.main_src = []
        self.dfb = []
        self.edt = []
        self.xdb_in_listfile = set()
        self.equipment_list = []
        
        self.equipments = EquipmentListParser()
        self.equipments.load_eqipmentlist(list_file)
        self.equipments_iter = self.equipments.iter_equipments()
        
    
    def compile_equipments(self, output):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        for key, ept in self.equipments_iter:
            self._add_equipment(self.template.get_functionblock(key), ept)
        
        if output:
            self._output_equipmentlist()
        
        
    def _output_equipmentlist(self):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        titles = ['设备ID', '参数1']
         
        wb = self.equipments.workbook
        
        ws = wb['设备列表']
        
        titles_sheet = [cell.value for cell in ws[1]]
        titles_column_num = {t:titles_sheet.index(t) + 1 for t in titles}
        
        values_filled = [[self._guid_to_crc32(ept[3])[1:], [self._convert_param(p[1]) for p in ept[5]]] for ept in self.equipment_list]
        
        t_id = titles_column_num['设备ID']
        t_pa = titles_column_num['参数1']
        
        cell_items_lines = [[(t_id, eid)] + [(t_pa + i, pa) for i, pa in enumerate(pas)] for eid, pas in values_filled]
        
        fill = PatternFill("solid", fgColor = "DDDDDD")
        
        for i, cell_items_line in enumerate(cell_items_lines):
            for cell_items in cell_items_line:
                cell = ws.cell(row = 2 + i, column = cell_items[0])
                if re.match('^\d+$', cell_items[1]):
                    cell.fill = fill
                cell.value = cell_items[1]
        
        head, tail = os.path.split(self.equipments.list_file)
        wb.save(os.path.join(head, 'output_' + tail[5:-5] + '.xlsx'))


    def _convert_param(self, param):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        if re.match('^%{0,1}[Mm][Ww]\d+$', param):
            return '4{:04}'.format(int(re.findall('\d+', param)[0]) + 1)
        return param
        
    
    def _add_equipment(self, function_block, equipment):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        fb_param =function_block[2]
        ept_param = equipment[5][:]
        l = len(fb_param) - len(ept_param)
        ept_param.extend(['/'] * (l if l >= 0 else 0))
        
        symbol = {'DI':':=', 'DO':'=>', 'AI':':=', 'AO':'=>', 'DL':':=', 'AL':':=', 'AS':':=', 'AF':'=>'}
        param_group = list(starmap(self._fill_param_addr, zip(fb_param, ept_param)))
        param_block = ', '.join([f'{fb[3]} {symbol[fb[1]]} {ept}' for fb, ept in param_group])

        db_name = self._guid_to_crc32(equipment[3])[1:]
        self.main_src.append('{}({});'.format(db_name, param_block))
        self.edt.extend([[ept, fb[2], f'%{ept}'] for fb, ept in param_group if fb[1] in ['AS', 'AF']])
        
        xdb_pack_raw = re.findall(r'\w+', function_block[1])
        xdb_pack = [xdb.lower() for xdb in xdb_pack_raw]
        self.xdb_in_listfile.update(xdb_pack)
        self.dfb.append([db_name, xdb_pack[0]])
        
        self.equipment_list.append(equipment[:5] + [param_group])
        

    def _fill_param_addr(self, fb, ept):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        if fb[1] not in ['DL', 'AS', 'AF']:
            return fb, ept
        if fb[1] == 'DL':
            return fb, self._guid_to_crc32(ept)[1:] + '.' + fb[4].split('.')[1]
        
        pointer = self.map[fb[1]][fb[2]]
        pointer[0] = pointer[0] + pointer[1]
        return fb, 'MW{:03}'.format(pointer[0])     
        
    
    def _guid_to_crc32(self, guid):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        return  '{:#010x}'.format(binascii.crc32(bytes.fromhex(guid.replace('-', ''))))
        

    def generate_xpgfile(self, target):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        try:
            xdb_files = [self.xdb_files[xdb] for xdb in list(self.xdb_in_listfile)]
            xdb = [self.xdb[xdb] for xdb in list(self.xdb_in_listfile)]
        except KeyError as e:
            raise UserError(f'xdb {str(e)} not found.')
        
        xdb_files_time = [os.path.getmtime(file) for file in xdb_files]
        src_files_time = xdb_files_time + [os.path.getmtime(self.template.template_file), os.path.getmtime(self.equipments.list_file)] 
        if os.path.isfile(target) and os.path.getmtime(target) > max(src_files_time):
            return None
        
        impl = xml.dom.minidom.getDOMImplementation()
        self.dom = impl.createDocument(None, 'PGMExchangeFile', None)
        
        nodes = {}
        element_PGMExchangeFile = self.dom.documentElement
        nodes[0] = [element_PGMExchangeFile]
        
        element_fileHeader = self._create_fileHeader_element()
        nodes[1] = [element_fileHeader]
        
        element_contentHeader = self._create_contentHeader_element()
        nodes[1].append(element_contentHeader)
        
        element_logicConf = self._create_logicConf_element()
        nodes[1].append(element_logicConf)
        
        element_program = self._create_program_element()
        nodes[1].append(element_program)
        
        element_dataBlock = self._create_dataBlock_element()
        nodes[1].append(element_dataBlock)
        
        nodes[1].extend(xdb)

        self._append_child_format(nodes[0][0], nodes[1], 1)

        with open(target, mode = 'w', encoding = 'utf-8') as f:
            self.dom.writexml(f, encoding='utf-8')

        return target

    def _create_fileHeader_element(self):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        attribute_company = self.dom.createAttribute('company')
        attribute_product = self.dom.createAttribute('product')
        attribute_dateTime = self.dom.createAttribute('dateTime')
        attribute_content = self.dom.createAttribute('content')
        attribute_DTDVersion = self.dom.createAttribute('DTDVersion')
        
        element_fileHeader = self.dom.createElement('fileHeader')
        
        element_fileHeader.setAttributeNode(attribute_company)
        element_fileHeader.setAttributeNode(attribute_product)
        element_fileHeader.setAttributeNode(attribute_dateTime)
        element_fileHeader.setAttributeNode(attribute_content)
        element_fileHeader.setAttributeNode(attribute_DTDVersion)
        
        element_fileHeader.setAttribute('company', "Schneider Automation")
        element_fileHeader.setAttribute('product', "Unity Pro XL V13.0 - 170914B")
        element_fileHeader.setAttribute('dateTime', 'date_and_time#' + datetime.now().isoformat('-', 'seconds'))
        element_fileHeader.setAttribute('content', "多程序源文件")
        element_fileHeader.setAttribute('DTDVersion', "41")
        
        return element_fileHeader
    
    
    def _create_contentHeader_element(self):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        attribute_name = self.dom.createAttribute('name')
        attribute_version = self.dom.createAttribute('version')
        attribute_dateTime = self.dom.createAttribute('dateTime')
        
        element_contentHeader = self.dom.createElement('contentHeader')
        
        element_contentHeader.setAttributeNode(attribute_name)
        element_contentHeader.setAttributeNode(attribute_version)
        element_contentHeader.setAttributeNode(attribute_dateTime)
        
        element_contentHeader.setAttribute('name', "项目")
        element_contentHeader.setAttribute('version', "0.0.1")
        element_contentHeader.setAttribute('dateTime', 'date_and_time#' + datetime.now().isoformat('-', 'seconds'))

        return element_contentHeader
    
    
    def _create_logicConf_element(self):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        nodes = {}
        
        element_logicConf = self.dom.createElement('logicConf')
        nodes[0] = [element_logicConf]
        
        attribute_resName = self.dom.createAttribute('resName')
        attribute_resIdent = self.dom.createAttribute('resIdent')
        element_resource = self.dom.createElement('resource')
        element_resource.setAttributeNode(attribute_resName)
        element_resource.setAttributeNode(attribute_resIdent)
        element_resource.setAttribute('resName', "Micro Basic")
        element_resource.setAttribute('resIdent', "BMX P34 2020 02.70")
        nodes[1] = [element_resource]
        
        attr = dict(task="MAST",taskType="cyclic",valueType="0",maxExecTime="250")
        element_taskDesc = self._create_element('taskDesc', attr)
        nodes[2] = [element_taskDesc]
        
        attr = dict(name="main",SectionOrder="1")
        element_sectionDesc = self._create_element('sectionDesc', attr)
        nodes[3] = [element_sectionDesc]
        
        self._append_child_format(nodes[0][0], nodes[1], 2)
        self._append_child_format(nodes[1][0], nodes[2], 3)
        self._append_child_format(nodes[2][0], nodes[3], 4)
        
        return element_logicConf
    
    
    def _create_program_element(self):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        nodes = {}
        
        element_program = self.dom.createElement('program')
        nodes[0] = [element_program]
        
        attr = dict(name="main",type="section",task="MAST")
        element_identProgram = self._create_element('identProgram', attr)
        nodes[1] = [element_identProgram]
        
        attr = dict()
        element_STSource = self._create_element('STSource', attr)
        nodes[1].append(element_STSource)
        
        description = '(* This file is automatically generated by simpliruna.py. DO NOT EDIT! *)\n\n'
        text_node_src = self.dom.createTextNode(description + '\n'.join(self.main_src))
        element_STSource.appendChild(text_node_src)
        
        self._append_child_format(nodes[0][0], nodes[1], 2)

        return element_program


    def _create_dataBlock_element(self):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        nodes = {}
        
        element_dataBlock = self.dom.createElement('dataBlock')
        nodes[0] = [element_dataBlock]
        
        nodes[1] = [self._create_element('variables', dict(name=n,typeName=t)) for n, t in self.dfb]
        nodes[1].extend([self._create_variables_elements_edt(edt) for edt in self.edt])
        
        self._append_child_format(nodes[0][0], nodes[1], 2)

        return element_dataBlock
        
        
    def _create_variables_elements_edt(self, edt):
        """Display the busy symbols at the screen.

        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        nodes = {}
        
        attr = dict(name=edt[0],typeName=edt[1],topologicalAddress=edt[2])
        element_variables = self._create_element('variables', attr)
        nodes[0] = [element_variables]
        
        attr = dict(name="TimeStampSource",value="0")
        element_attribute = self._create_element('attribute', attr)
        nodes[1] = [element_attribute]
        
        self._append_child_format(nodes[0][0], nodes[1], 3)
        
        return element_variables
     
    
    def _create_element(self, element_tag, attributes):
        """Display the busy symbols at the screen.
        
        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        nodes_attribute = [self.dom.createAttribute(attr_name) for attr_name in attributes.keys()]
        nodes_element = self.dom.createElement(element_tag)
        [nodes_element.setAttributeNode(attr_node) for attr_node in nodes_attribute]
        [nodes_element.setAttribute(name, value) for name, value in attributes.items()]
        return nodes_element
    

    def _append_child_format(self, parent_node, child_nodes, indent):
        """Display the busy symbols at the screen.
        
        The busy symbols will be update when the function called everytime.

        Parameter:
        info : sting --- the information displayed after the busy symbol.
        """
        n = len(child_nodes)
        text_nodes = [self.dom.createTextNode('\n' + '\t' * indent) for i in range(n)]
        nodes_formatted = [node for grp in zip(text_nodes, child_nodes) for node in grp]
        text_node_end = self.dom.createTextNode('\n' + '\t' * (indent - 1))
        nodes_formatted.append(text_node_end)
        [parent_node.appendChild(node) for node in nodes_formatted]


def isthistype(file, this_type):
    """Verify the file type.

    Return True if 'file' is an existing regular file and the file type is 'this_type'.

    Parameter:
    file : string --- the file to be verified.
    this_type: string --- the file type expected
    """
    return os.path.splitext(file)[-1] == this_type
    

def islistfile(file):
    """Display the busy symbols at the screen.

    The busy symbols will be update when the function called everytime.

    Parameter:
    info : sting --- the information displayed after the busy symbol.
    """
    root, ext = os.path.splitext(os.path.basename(file))
    return ext == '.xlsx' and re.match(r'^list_[^<>:;,?"*|/]+$', root)


def get_list_files():
    """Display the busy symbols at the screen.

    The busy symbols will be update when the function called everytime.

    Parameter:
    info : sting --- the information displayed after the busy symbol.
    """
    if not os.path.isdir(project.project_dir):
        raise UserError(f'Project directory does not exist: \'{project.project_dir}\'')
    
    stations = {}
    dirpath, dirnames, filenames = next(os.walk(project.project_dir))
    for dirname in dirnames:
        dp, drs, fls = next(os.walk(os.path.join(dirpath, dirname)))
        stations.update({os.path.normcase(os.path.abspath(dp)):os.path.join(dp, f) for f in fls if islistfile(f)})
    log.append(0, f'{len(stations)} station(s) found in project directory')
    try:
        list_files = [stations[os.path.normcase(os.path.abspath(args.station))]] if args.station else list(stations.values())
    except KeyError:
        raise UserError(f'Station \'{args.station}\' not found in project directory \'{project.project_dir}\'')
    
    return list_files


def build_stations(list_files):
    """Display the busy symbols at the screen.

    The busy symbols will be update when the function called everytime.

    Parameter:
    info : sting --- the information displayed after the busy symbol.
    """
    list_files_split = [[file, os.path.split(file)] for file in list_files]
    xpg_files = {file:os.path.join(head, tail[5:-5] + '.xpg') for file, (head, tail) in list_files_split}
    
    if args.rebuild:
        for file in xpg_files.values():
            try:
                os.remove(file)
                log.append(0, f'Clean: Deleted file \'{file}\'.')
            except (IsADirectoryError, PermissionError) as error:
                log.append(1, f'Clean Warning: Can\'t delete file \'{file}\' from disk. {repr(error)}')
            except FileNotFoundError:
                log.append(1, f'Clean Warning: File \'{file}\' doesn\'t exist.')
    
    builder = StationBuilder()
    
    log.append(0, 'Loading template file...')
    builder.load_template(project.template_file)
 
    log.append(0, 'Loading xdb library...')
    builder.load_xdb(project.library_dir)
    
    log.append(0, 'Building stations...')
    
    for file in list_files:
        builder.load_equipments(file)
        builder.compile_equipments(args.output)
        
        if builder.generate_xpgfile(xpg_files[file]):
            log.append(0, f'The target \'{xpg_files[file]}\' is out of date. Has been Compiled.')
        else:
            log.append(1, f'The target \'{xpg_files[file]}\' is up to date. Has been Skipped')


if __name__ == '__main__':
    parser = argparse.ArgumentParser(allow_abbrev = False)
    parser.add_argument('project', help = 'the project file (.pro)')
    parser.add_argument('-s', '--station', help = 'the station directory')
    parser.add_argument('-r', '--rebuild', action = 'store_true', help = 'Rebuild')
    parser.add_argument('-o', '--output', action = 'store_true', help = 'Output xlsx')
    args = parser.parse_args()
    
    log = Log('.\\logfile.log')
    
    try:
        log.append(0, 'Starting application...')
        start_time = datetime.now()
        
        log.append(0, 'loading project file...')
        project = ProjectParser()
        project.read(args.project)
        
        log.append(0, 'Searching stations...')
        list_files = get_list_files()
        
        build_stations(list_files)
        
        time_span = datetime.now() - start_time
        log.append(0, f'Mission complete! Elapsed time {time_span.seconds}.{time_span.microseconds}s.')
        
        # print('\n  Press any key to exit...')
        # os.system('pause>nul')
    
    except Exception as error:
        log.append(2, f'Fatal error: {str(error)}')
        print(f'\n\033[95m\rAn error occurred. See the log file {os.path.abspath(log.logfile)}')
    
    log.record()
